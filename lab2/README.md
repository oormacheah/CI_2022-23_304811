# Lab 2 - Set Covering with GA

## Approach
This problem was tackled following a similar approach as in professor's example of the *OneMax* problem. Some preliminary things to consider:
- The main evolution loop was taken from professor's solution. The only slight difference is the parametrization of `MUTATION_RATE` and `TOURNAMENT_SIZE`.
- Only the GA functions were implemented.
- New tuple objects have to be allocated for each individual. This is because the potential mutations and cross-overs will yield lists that are not in the original List of Lists (generated by the `problem()` function from lab1) so storing the indexes won't work.

### Initial population
The initial population was generated by sampling the original list of lists from lab1 `POPULATION_SIZE` times and taking a random amount of lists at each iteration. Each sample (subset) was casted to an `Individual` object.

### Genome
A list of lists (of unconstrained size) is a genome.

### Fitness
The measure for fitness is a tuple containing 3 elements (in order of priority):
1) Number of distinct elements covered by the genome
2) Bloat -> negative sum of the elements' multiplicity (if it isn't 1)
3) Number of elements that appear only once in the genome

This representation allows the *tournaments* to be just a `max()` among individual's fitness

### Cross-over
**Problem**: Two given genomes have no constraints about the size of the genome (i.e. number of lists nor their length)

**Idea**: Generate a random float from 0 to 1. It will correspond to a cut percentage and the cuts will be made proportionally. For example, assume we have g1 and g2 and the random number turns out 0.25. So, the new genome will be constituted of the first 25% of g1 and the last 75% of g2. I couldn't think of a more "fair" way to perform the cut (feedback would be appreciated :D).

### Mutation
They happen with a frequency of `MUTATION_RATE` (tweakable). A random element (number) of a random list of the given genome is selected. Then, it is added or subtracted 1. I thought that just replacing it with a random number in the appropriate range was a bit "too random".

**Problem**: The selected element may turn into an invalid number for the problem (e.g. -1 if the number was originally 0 and it is subtracted by 1). This doesn't completely destroy the algorithm, but it may consider the corresponding genome "fitter" because it will add the -1 to the set covered, which is definitely wrong.

**Solution (?)**: In these limit cases, the mutation is not random anymore. It is enforced (+1 or -1) to be such that the number doesn't fall out of range. It may not be the most fair approach.

## Results
The results seem to always converge. The population ends up being all the same.

Tweaking `POPULATION_SIZE`, `OFFSPRING_SIZE`, and `NUM_GENERATIONS`, these are the most relevant results:
- `N = 500` -> w = 2200 ~ 2500 
- `N = 1000`-> w = 6300 ~ 6700